## 20191226

[TOC]

### 复合数据类型

跟随老男孩go视频教程，学些数组和切片

Go语言中存在三种复合数据类型：数组，切片，映射

#### 数组

数组是切片和映射的基础数据结构。了解数组的工作原理，有助于理解切片和映射提供的优雅、强大的功能。

数组是具有**相同类型**的一组已经编号且**长度固定**的数据项序列，数组长度也是数组类型的一部分。

##### 声明数组

```go
// 声明一个包含5个元素的整型数组
var array [5]int
```

数组一旦声明，它存储的数据类型和数组长度便都不能修改了。如果需要存储更多的元素，必须先创建一个更长的数组，然后把原来数组里的值复制到新数组里。

Go语言在声明变量时，都是使用相应类型的零值来初始化变量的。

##### 初始化

```go
// 使用数组字面量
array := [5]int{10, 20, 30, 40, 50}

// 使用...替代数组的长度,Go 语言会根据初始化数组元素的数量来确定该数组的长度
array := [...]int{10, 20, 30, 40, 50}

// 用具体值初始化索引为1和2的值
array := [5]int{1: 10, 2: 20}
```

##### 访问与修改

Go语言数组通过数组下标来读取和修改数组元素。

##### 将数组传递给函数

Go语言数组是值类型，也就是说在赋值和作为参数传递时都将产生一次复制动作，在函数体中无法修改传入的数组的内容。

数组变量的类型包括数组长度和每个元素的类型。只有这两部分都相同的数组，才是类型相
同的数组，才能互相赋值。

复制数组指针，只会复制指针的值，而不会复制指针所指向的值。

所以在函数传递大数组的时候，可以只传入指向数组的指针，这样只需要复制8字节的数据。

##### 多维数组

**声明**/**访问**/

```go
var array [4][2]int
array[0][0] = 10
array[0][1] = 20
array[1][0] = 30
array[1][1] = 40
```



#### 切片

切片是围绕动态数组的概念构建，可以按需自动增长和缩小，动态增长通过append函数实现。

##### 内部实现

切片有3个字段分别指向底层数组的指针，切片访问的元素的个数（长度）和切片允许增长到的元素个数（容量）。

##### 创建切片

1. 使用make

```go
// 创建长度为3, 容量是5的一个字符串切片
slice := make([]string, 3, 5)
```

2. 切片字面量

```go
slice := []int{l0, 20, 3θ}
// 使用空字符串初始化第100个元素
slice := []string{99: ""}
```

**如果在口运算符里指定了一个值，那么创建的就是数组而不是切片，只有不指定值时才会创建切片**

##### 空切片/nil切片

只声明，不初始化，就会创建一个nil切片。

``` go
// nil切片
var slice []int
// 空切片, 空切片在底层数组包含0个元素，也没有分配任何存储空间
slice := make([]int, 0)
slice := []int{}

```

##### 使用切片

```go
// 创建一个整型切片
// 其长度和容量都是5个元素
slice := []int{10, 20, 30, 40, 50}

// 创建一个新切片
// 长度为2个元素，容量为4个元素
newSlice := slice[1:3]

// 使用3个索引创建切片，第三个参数是限制容量用的
newSlice2 := slice[2:3:4]

// 额外的容量元素也是不能访问的
长度: j – i 或3 - 2 = 1
容量：k -i 或 4 - 2 = 2
```

##### 切片扩容

```go
slice := []int{10, 20, 30, 40, 50}
newslice := slice[1:3]
newSlice = append(newSlice, 60)
```

如果切片的底层数组没有足够的可用容量，append()函数会创建一个新的底层数组，被引用的现有值复制到新数组里，再追加新的值。

##### 遍历切片

使用for... range

```go
slice := []int{10, 20, 30, 40}
for index, value := range slice {
    fmt.Printf("index: %d value: %d\n", index,value)
}
```

range创建的是每个元素的副本，而不是返回该元素的引用。

另外内置函数len()和cap()可以返回切片的长度和容量。

##### 在函数间传递切片

由于与切片关联的数据包含在底层数组里，不属于切片本身，所以将切片复制到任意函数的时候，对底层数组大小都不会有影响。复制时只会复制切片本身，不会涉及底层数组。



==============================================

待合并

==============================================

### 数组

定义数组，数量写在类型的前面

```go
var arry1 [5]int
// 使用“:=”的时候必须给与初始值
arr2 := [3]int{1, 3, 5} 
// “...”表示让编译器根据后面的值帮我们确定具体的个数
arr3 := [...]int{1, 2, 3, 4} 
// 定义多维数据，4行5列，4个长度为5的数组
var grid [4][5]bool 
```

数组的遍历

```go
// 使用for循环
for i:=0; i<len(arr3); i++ {
	fmt.Println(arr3[i])
}
// 使用range
for i, v := range arr3  {
	fmt.Println(i, v)
}

```

数组是值类型

[10]int 和 [20]int 是不同类型

调用func f(arr [10]int) 会拷贝数组

```go
// 数组是值传递
func printArray(arr [5]int) {
	arr[0] = 100
	for i, v := range arr {
		fmt.Println(i, v)
	}
}

// 可以使用数组指针
func printArray(arr *[5]int) {
    arr[0] = 100
	for i, v := range arr {
		fmt.Println(i, v)
	}
}
```

go语言中一般不直接使用数组，使用**切片**

### 切片Slice

切片的底层实现是数组

Slice本身没有数据，是对底层array的一个view

```go
arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}
s := arr[2:6]
s[0] = 10
```

Slice的扩展

