## 20200521

[TOC]

#### 切片

切片是围绕动态数组的概念构建，可以按需自动增长和缩小，动态增长通过append函数实现。

##### 内部实现

Slice本身没有数据，是对底层array的一个view。

切片有3个字段分别指向底层数组的指针，切片访问的元素的个数（长度）和切片允许增长到的元素个数（容量）。

##### 创建切片

1. 使用make

```go
// 创建长度为3, 容量是5的一个字符串切片
slice := make([]string, 3, 5)
```

2. 切片字面量

```go
slice := []int{l0, 20, 3θ}
// 使用空字符串初始化第100个元素
slice := []string{99: ""}
```

**如果在口运算符里指定了一个值，那么创建的就是数组而不是切片，只有不指定值时才会创建切片**

##### 空切片/nil切片

只声明，不初始化，就会创建一个nil切片。

在空切片上面应用内建函数将会得到0。

``` go
// nil切片
var slice []int
// 空切片, 空切片在底层数组包含0个元素，也没有分配任何存储空间
slice := make([]int, 0)
slice := []int{}

```

##### 使用切片

```go
// 创建一个整型切片
// 其长度和容量都是5个元素
slice := []int{10, 20, 30, 40, 50}

// 创建一个新切片
// 长度为2个元素，容量为4个元素
newSlice := slice[1:3]

// 使用3个索引创建切片，第三个参数是限制容量用的
newSlice2 := slice[2:3:4]

// 额外的容量元素也是不能访问的
长度: j – i 或3 - 2 = 1
容量：k -i 或 4 - 2 = 2
```

使用cap方法可以获取到容量。一个切片值的容量是从其中的指针指向的那个元素值到顶层数组的最后一个元素值的计数值。

##### 切片操作

**扩容**

```go
slice := []int{10, 20, 30, 40, 50}
newslice := slice[1:3]
newSlice = append(newSlice, 60)
```

如果切片的底层数组没有足够的可用容量，**append**函数会创建一个新的底层数组，被引用的现有值复制到新数组里，再追加新的值。

slice可以向后扩展，不可以向前扩展

slice[i]不可以超越len(s)，向后扩展不可以超越底层数组cap(slice)

*注意，append函数并不是在原切片值之上进行扩展的，而且是创建一个新的切片值。*

我们还可以使用append函数把两个元素类型相同的切片值连接起来。

**复制**

```go
sliceA := []string{"Notepad", "UE", "Eclipse"}
sliceB := []string{"Vim", "Emacs", "Lite IDE", "IDEA"}
n1 := copy(sliceA, sliceB)
```

内建copy的作用是把源切片值（第二个参数）中的元素值复制到目标切片值（第一个参数）中，并且返回被复制的元素值的数量（int)。

实际复制的元素值的数量将等于长度较短的那个切片值的长度。

不像append函数那样，copy函数会改变与其第一个参数绑定的那个值。

**删除**

没有删除方法，可以通过如下方式达到目的

``` go
// 删除第四个元素
s2 = append(s2[:3], s2[4:]...)
// 删除头
s2 = s2[1:]

// 删除尾
s2 = s2[:len(s2)-1]
```

##### 遍历切片

使用for... range

```go
slice := []int{10, 20, 30, 40}
for index, value := range slice {
    fmt.Printf("index: %d value: %d\n", index,value)
}
```

range创建的是每个元素的副本，而不是返回该元素的引用。

另外内置函数len()和cap()可以返回切片的长度和容量。

##### 在函数间传递切片

由于与切片关联的数据包含在底层数组里，不属于切片本身，所以将切片复制到任意函数的时候，对底层数组大小都不会有影响。复制时只会复制切片本身，不会涉及底层数组。

那么怎样批量复制切片值中的元素呢？可以使用上面提到的内建copy函数。

